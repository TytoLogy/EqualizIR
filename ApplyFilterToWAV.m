function ApplyFilterToWAV(varargin)
%------------------------------------------------------------------------
% ApplyFilterToWAV
%------------------------------------------------------------------------
% 
% given filter information in EQ struct, loads a wav file, applies filter
% and then saves to new wav file.
% 
% designed to be called from EqualizIR application!
%------------------------------------------------------------------------
% Input Arguments:
% 	(all are optional - program will ask for inputs that are not provided on
% 	command line)
%
% 		'EQ', <EQualization data struct>
% 			EQ struct is generated by EqualizIR application, with fields:
% 			Fs			sample rate for impulse response, filter (samples/sec)
% 							¡¡this must match that of sound files to be processed!!!
% 			NFFT		length of impulse response (samples)
% 			NZ			number of zeros for filter
% 			NP			number of poles for filter
% 			InterpMethod	Interpolation method used to complete correction
% 								spectrum (sent as argument to josInv.m function)
% 			EQMethod			method used to compute equalization factor
% 									{'COMPRESS', 'ATTEN', 'BOOST'}
% 			TargetLevel		level used as target by COMPRESS method
% 			caldata	calibration data struct
%			CalSmoothMethod	method used to smooth calibration data before
% 									generating filter
% 										{'SAVGOL', 'MOVAVG'}
% 			CalSmoothParameters	settings for smoothing method
% 										For SAVGOL, [order, framesize]
% 										For MOVAVG, [window size]
% 			EQmags	equalization values calculated by EQ method
% 							¡calculated at frequencies specified in caldata struct, 
% 							 NOT at frequencies in f, G arrays - those are calculated
% 							 separately using the EQmags!
%			CorrectionLimit	limit to correction value in dB. if 0, no limit!
% 			f			[DC:Fs/2] frequencies for full equalization spectrum
% 			G			[DC:Fs/2] Gain values for equalization
% 			A, B		denominator, numerator filter coefficients that can be 
% 						used with the filter or filtfilt MATLAB commands to apply
% 						the equalization to sound arrays
% 			Finv		invert struct from josInv output
%
%		'EQFILE', <filename>			path/name of .EQ file from EqualizIR
% 		'WAVFILE', <filename>		path/name of .WAV file to be equalized
% 		'ADJFILE', <filename>		path/name of .WAV file for equalized sound
% 		'RAMPMS', <ramp duration>	duration of onset/offset ramp in milliseconds
% 		'PLOTSPECTRA', <'y' or 'n'>	plot spectrograms of data (might cause
% 												a crash for long stimuli!!!!)
% 												
% Output Arguments:
% 	NONE
%
% Example:
%	ApplyFilterToWAV(	'EQFILE', 'filterdata.eq', ...
%							'WAVFILE', 'sounds.wav', ...
%							'ADJFILE', 'sounds_equalized.wav', ...
%							'RAMPMS', 2, ...
%							'PLOTSPECTRA', 'n');
% 
%------------------------------------------------------------------------
% See also: EqualizIR, filtfilt
%------------------------------------------------------------------------

%------------------------------------------------------------------------
% Sharad J. Shanbhag
% sshanbhag@neomed.edu
%------------------------------------------------------------------------
% Created: 6 January, 2017 (SJS)
%
% Revisions:
%	9 Jan 2017 (SJS): added input arguments to allow comand-line use
%	24 Mar 2015 (SJS): modified to account for older versions of Matlab
%							 that don't have audioread/audiowrite/audioinfo
%							 functions (use wavread/wavwrite instead)
%------------------------------------------------------------------------
% TO DO:
%------------------------------------------------------------------------

%------------------------------------------
% plotting options for spectrograms
%------------------------------------------
specg_win = 1024;
specg_olap = 128;
specg_fftwin = 2048;

%---------------------------------------------------
% define some variables - values will be assigned later
%---------------------------------------------------
EQ = [];
rampdur = [];
eqname = '';
eqpath = '';
wavname = '';
wavpath = '';
adjname = '';
adjpath = '';
PLOTSPECTRA = 0;

%------------------------------------------
% Parse varargs
%------------------------------------------
n = 1;
while n <= length(varargin)
	switch upper(varargin{n})
		case 'EQ'
			if isstruct(varargin{n+1})
				EQ = varargin{n+1};
			else
				error('%s: EQ must be a struct', mfilename);
			end
			n = n + 2;
		case 'EQFILE'
			[fpath, fname, fext] = fileparts(varargin{n+1});
			eqname = [fname fext];
			eqpath = fpath;
			n = n + 2;
		case 'WAVFILE'
			[fpath, fname, fext] = fileparts(varargin{n+1});
			wavname = [fname fext];
			wavpath = fpath;
			n = n + 2;
		case 'ADJFILE'
			[fpath, fname, fext] = fileparts(varargin{n+1});
			adjname = [fname fext];
			adjpath = fpath;
			n = n + 2;
		case 'RAMPMS'
			rampdur = varargin{n+1};
			n = n + 2;
		case 'PLOTSPECTRA'
			tmp = upper(varargin{n+1});
			if tmp(1) == 'Y'
				PLOTSPECTRA = 1;
			else
				PLOTSPECTRA = 0;
			end
			n = n + 2;
		otherwise
			error('%s: unknown input parameter %s', mfilename, varargin{n});
	end
end
%------------------------------------------
% If no input arg, load EQ data
%------------------------------------------
if isempty(EQ)
	if isempty(eqname)
		[eqname, eqpath] = uigetfile( '*.eq', 'Load .EQ file...');
		if eqname == 0
			return
		end
	end
	load(fullfile(eqpath, eqname), '-MAT', 'EQ');
end
%------------------------------------------
% load sound (wav) file
%------------------------------------------
% get file name if not provided
if isempty(wavname)
	[wavname, wavpath] = uigetfile( '*.wav', 'Load .WAV file...');
	if wavname == 0
		return
	end
end
% check if audioread is valid function
if exist('audioread') %#ok<*EXIST>
	% get file info
	winfo = audioinfo(fullfile(wavpath, wavname));
	% make sure sample rates match!!!!
	if winfo.SampleRate ~= EQ.Fs
		errordlg(sprintf( ['WAV sample rate (%d) ' ...
								'does not match EQ sample rate (%d)'], ...
								winfo.SampleRate, EQ.Fs));
		return
	end
	% load file
	fprintf('Loading WAV file %s ... \n', fullfile(wavpath, wavname));
	[wdata, Fs] = audioread(fullfile(wavpath, wavname), 'native');
	fprintf('...done.\n');
else
	% no audioread, so use wavread
	[wdata, Fs, nbits, opts] = wavread(fullfile(wavpath, wavname)); %#ok<DWVRD>
	% make sure sample rates match!!!!
	if Fs ~= EQ.Fs
		errordlg(sprintf( ['WAV sample rate (%d) ' ...
								'does not match EQ sample rate (%d)'], ...
								Fs, EQ.Fs));
		return
	end
	% assign values to winfo
	winfo = struct(	'Filename', fullfile(wavpath, wavname), ...
							'CompressionMethod', 'Uncompressed', ...
							'NumChannels', min(size(wdata)), ...
							'SampleRate', Fs, ...
							'TotalSamples', length(wdata), ...
							'Duration', Fs*length(wdata), ...
							'Title', [], ...
							'Comment', opts, ...
							'Artist', [], ...
							'BitsPerSample', nbits	);
end
% need wdata to be a row vector for some future functions to work
if ~isrow(wdata)
	wdata = wdata';
end
%------------------------------------------
% create output name here
%------------------------------------------
if isempty(adjname)
	[~, fname, fext] = fileparts(wavname);
	adjname = [fname '_eq' fext];
	adjpath = wavpath;
	% get filename and path
	[adjname, adjpath] = uiputfile(fullfile(adjpath, adjname), ...
									'Save equalized WAV file');
	if adjname == 0
		return
	end
end
%------------------------------------------
% ask about onset/offset ramp duration
%------------------------------------------
if isempty(rampdur)
	rampdur = uiaskvalue('value', 5, ...
								'questiontext', 'Enter on/off ramp duration', ...
								'valuetext', 'Ramp Duration (ms)');
end
if rampdur < 0
	errordlg('Ramp duration must be greater than or equal to 0!');
	return
else
	fprintf('Using %d ms window for onset/offset ramp\n', rampdur);
end
%------------------------------------------
% convert to double, normalize, apply ramp
%------------------------------------------
fprintf('Converting to double precision, normalizing, applying ramp\n');
if rampdur
	wdata = sin2array(normalize(double(wdata)), rampdur, Fs);
else
	wdata = normalize(double(wdata));
end
%------------------------------------------
% then apply filter
%------------------------------------------
fprintf('Applying filter using filtfilt function and normalizing to 0.95...\n');
tic
wdataf = 0.95*normalize(filtfilt(EQ.B, EQ.A, wdata));
Tfilt = toc;
fprintf('...done in %.4f seconds\n', Tfilt);
%------------------------------------------
% plots
%------------------------------------------
if PLOTSPECTRA
	% plot spectra
	fprintf('Plotting spectra...');
	fftdbplot(wdata, Fs, 7);
	fftdbplot(wdataf, Fs, 8);
	fprintf('... done');
	% plot spectrograms
	figure(9)
	% raw
	subplot(211)
	fprintf('Plotting raw spectrogram ...\n');
	tic
	spectrogram(wdata, specg_win, specg_olap, specg_fftwin, Fs, 'yaxis');
	colormap('gray');
	map=colormap;
	colormap(1-map);
	colorbar
	title(fprintf('%s: raw', wavname), 'Interpreter', 'none');
	drawnow
	Trawspec = toc;
	fprintf('...done in %.4f seconds\n', Trawspec);
	% filtered
	subplot(212)
	fprintf('Plotting adj spectrogram ...\n');
	tic
	spectrogram(wdataf, specg_win, specg_olap, specg_fftwin, Fs, 'yaxis');
	colormap('gray');
	map=colormap;
	colormap(1-map);
	colorbar
	title(fprintf('%s: adj', adjname), 'Interpreter', 'none');
	drawnow
	Tadjspec = toc;
	fprintf('...done in %.4f seconds\n', Tadjspec);
end
%------------------------------------------
% Save file
%------------------------------------------
% if user didn't hit cancel button, save WAV at original sample rate and
% bitdepth
% check if audiowrite exists
if exist('audiowrite')
	audiowrite(fullfile(adjpath, adjname), wdataf, Fs, ...
							'BitsPerSample', winfo.BitsPerSample);
else
	wavwrite(wdataf, Fs, winfo.BitsPerSample, fullfile(adjpath, adjname)); %#ok<DWVWR>
end

